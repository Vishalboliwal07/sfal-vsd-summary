# Week 1 

<details>
	<summary>Day 1 - Introduction to Verilog RTL design and Synthesis </summary>
Day 1 - Introduction to Verilog RTL design and Synthesis
This section provides an introduction to Verilog RTL design and synthesis, covering the basics of the open-source simulator iverilog, practical labs using iverilog and gtkwave, an introduction to Yosys and logic synthesis, and hands-on labs with Yosys and Sky130 PDKs.

Introduction to open-source simulator iverilog
Icarus Verilog is an open-source Verilog simulator that allows for the simulation of digital circuits described in the Verilog Hardware Description Language (HDL). It is a valuable tool for debugging and verifying the functionality of your designs before they are synthesized into hardware. This section will cover the basics of installing and using iverilog to compile and simulate your Verilog code.

Labs using iverilog and gtkwave
In these labs, you will get hands-on experience with iverilog and the GTKWave waveform viewer. You will learn how to write simple Verilog modules, create testbenches to verify their functionality, and use GTKWave to visualize the simulation results. This will help you understand the behavior of your designs and debug any issues.

Introduction to Yosys and Logic synthesis
Yosys is an open-source synthesis tool that converts your Verilog RTL code into a netlist, which is a description of the circuit in terms of logic gates. This section will introduce the fundamental concepts of logic synthesis, including how Yosys optimizes your design for area and performance.

Labs using Yosys and Sky130 PDKs
These labs will guide you through the process of synthesizing your Verilog designs using Yosys and the Sky130 Process Design Kit (PDK). You will learn how to set up the synthesis flow, generate a netlist, and analyze the results. This will give you practical experience in preparing a design for fabrication.

Day 2 - Timing libs, hierarchical vs flat synthesis and efficient flop coding styles
This section focuses on timing libraries, the differences between hierarchical and flat synthesis approaches, and best practices for efficient flip-flop coding styles.

Introduction to timing .libs
Timing libraries, or .lib files, are crucial for static timing analysis (STA). They contain detailed information about the timing characteristics of the standard cells used in your design. This section will explain the structure and content of these libraries and how they are used to verify that your design meets its timing requirements.

Hierarchical vs Flat Synthesis
This section explores two different approaches to synthesis: hierarchical and flat. Hierarchical synthesis synthesizes each module of the design independently, which can be faster and easier to manage for large designs. Flat synthesis, on the other hand, synthesizes the entire design as a single unit, which can result in better optimization but may be more computationally intensive.

Various Flop Coding Styles and optimization
The way you code your flip-flops in Verilog can have a significant impact on the performance and area of your synthesized circuit. This section will cover different coding styles for flip-flops and discuss how to write efficient and synthesizable code that meets your design goals.

Day 3 - Combinational and sequential optimizations
This section delves into the various optimization techniques used for both combinational and sequential logic during the synthesis process.

Introduction to optimizations
Synthesis tools employ a wide range of optimization techniques to improve the quality of your design. This section provides an overview of these optimizations and explains how they help to reduce area, improve performance, and minimize power consumption.

Combinational logic optimizations
This section focuses on optimization techniques specifically for combinational logic. Topics will include logic simplification, Boolean algebra, and other methods used to reduce the complexity of the circuit while preserving its functionality.

Sequential logic optimizations
This section covers optimization techniques for sequential logic, such as state machine encoding, retiming, and clock gating. These techniques are used to improve the timing and power characteristics of your sequential circuits.

Sequential optimizations for unused outputs
In some cases, the outputs of sequential elements may not be used by any other part of the design. This section will discuss how synthesis tools can identify and remove these unused outputs to reduce the overall area of the circuit.

Day 4 - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch
This section covers Gate-Level Simulation (GLS), the important distinction between blocking and non-blocking assignments, and the potential for mismatches between synthesis and simulation results.

GLS, Synthesis-Simulation mismatch and Blocking/Non-blocking statements
Gate-Level Simulation (GLS) is a type of simulation that is performed on the synthesized netlist. It is used to verify the functionality and timing of the design after it has been optimized by the synthesis tool. This section will also discuss the critical difference between blocking (=) and non-blocking (<=) assignments in Verilog and how they can lead to synthesis-simulation mismatches if not used correctly.

Labs on GLS and Synthesis-Simulation Mismatch
In these labs, you will perform Gate-Level Simulations on your synthesized designs and learn how to identify and debug synthesis-simulation mismatches. This will give you a deeper understanding of the importance of writing synthesizable Verilog code.

Labs on synth-sim mismatch for blocking statement
These labs will focus specifically on how the use of blocking statements can lead to synthesis-simulation mismatches. You will see practical examples of this issue and learn how to avoid it in your own designs.

Day 5 - Optimization in synthesis
This section explores advanced optimization techniques used in synthesis, focusing on control structures like if and case statements, as well as for loops and generate blocks.

If Case constructs
This section will discuss how synthesis tools handle if and case statements in Verilog. You will learn how these constructs are translated into logic gates and how different coding styles can affect the quality of the synthesized circuit.

Labs on "Incomplete If Case"
In these labs, you will learn about the concept of "incomplete if case" statements and how they can lead to the inference of latches in your design. You will see how to identify and fix these issues to ensure that your design is purely combinational.

Labs on "Incomplete overlapping Case"
These labs will cover the topic of "incomplete overlapping case" statements. You will learn how these constructs can lead to unexpected behavior in your synthesized circuit and how to write your code to avoid these issues.

for loop and for generate
This section will explore the use of for loops and generate blocks in Verilog. You will learn how these constructs can be used to create regular and scalable hardware structures and how they are handled by the synthesis tool.

Labs on "for loop" and "for generate"
In these labs, you will get hands-on experience with for loops and generate blocks. You will learn how to use these constructs to create complex hardware designs and how to write efficient and synthesizable code.
